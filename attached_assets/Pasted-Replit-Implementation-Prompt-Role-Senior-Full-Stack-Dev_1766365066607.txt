Replit Implementation Prompt
Role: Senior Full Stack Developer Context: I am building a "Cover Making Application" using FastAPI (Python) and React. I need to implement a Supplier and Material sourcing system.

Task: Please implement the following features into the existing project structure:

1. Database Schema Updates (SQLAlchemy)
suppliers Table: Fields for id, business_name, contact_name, address, phone, email, and website.

supplier_materials (Association Table): This links suppliers to materials. It must include:

supplier_id and material_id (Foreign Keys).

unit_cost: The price this specific supplier charges for this material.

is_preferred: A boolean flag. Constraint: For any given material_id, only one supplier can have is_preferred = True.

materials Table Update: Ensure it has a relationship to find its associated suppliers.

2. Backend Logic (FastAPI)
CRUD Endpoints: * Full CRUD for Suppliers.

An endpoint to link/unlink a material to a supplier with a specific cost.

An endpoint PATCH /materials/{id}/set-preferred-supplier that takes a supplier_id, sets it as the preferred source for that material, and toggles all other suppliers for that material to is_preferred = False.

Pricing Engine Integration: Update the pricing service logic so that when calculating the "Material Cost," it automatically fetches the unit_cost from the supplier_materials record where is_preferred is True.

3. Frontend UI (React + MUI)
Supplier Management Page: A table to view, add, and edit supplier contact details.

Material Sourcing Tab: Inside the Material detail view, add a section to:

See a list of all suppliers who sell this material.

Compare their different unit costs.

A "Set as Preferred" button/radio toggle to switch which supplier's price is used for the app's global calculations.

4. Technical Requirements
Use Pydantic schemas for request validation.

Use SQLAlchemy for the Many-to-Many relationship with extra data (the unit cost).

Provide the Alembic migration steps or updated models.py.

Why this approach works
The "Preferred Vendor" Toggle: By using a boolean flag (is_preferred) on the relationship table, you don't have to hardcode a price into the Material table. If Supplier A raises prices, you can simply add Supplier B, enter their lower price, and click "Set as Preferred." The Pricing Engine will immediately start using the new value.

Historical Data: This structure allows you to keep a record of who sells what, even if you aren't currently buying from them.

Data Integrity: The backend logic ensures that you can't accidentally have two "preferred" prices for one material, which would break your pricing calculations.

Next Step for You
Would you like me to write the specific SQLAlchemy Model code for the SupplierMaterial association table so you can paste it directly into your models.py?