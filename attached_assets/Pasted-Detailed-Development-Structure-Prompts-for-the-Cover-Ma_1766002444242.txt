Detailed Development Structure & Prompts for the Cover Making Application
This document provides an expanded plan for building a web based application to manage custom fabric covers for musical instruments, calculate prices, and generate Amazon/eBay/Reverb listing templates. It leverages a modern web stack (Python + FastAPI backend with SQLAlchemy/Alembic, React frontend) 
1. Project Overview
The application must:
•	Manage manufacturers, series, models, materials, suppliers, and customers.
•	Capture model dimensions and design options (handle location, angle type) and associate images via URLs.
•	Compute cost and weight of covers using material properties, labour time, option surcharges, waste percentage, and shipping rates.
•	Maintain marketplace product types (e.g., Amazon templates) with fields, required flags, valid values, and item type keywords.
•	Allow users to create orders (with line items) tied to marketplace order numbers.
•	Provide a UI for managing data, calculating prices, and exporting listings in the exact layout of Amazon spreadsheets.
•	Store marketplace templates (like CARRIER_BAG_CASE) in the database, including the Data Definitions, Valid Values, and Template layout.
2. Data Modelling (SQLAlchemy)
Define the following models using SQLAlchemy’s declarative style:
Core Entities
Model	Fields & Relationships
Manufacturer	id (PK), name (str, unique)
Series	id (PK), name (str), manufacturer_id (FK → Manufacturer), unique constraint on (manufacturer_id, name)
EquipmentType	id (PK), name (str), uses_handle_options (bool), uses_angle_options (bool)
Model	id (PK), name (str), series_id (FK → Series), equipment_type_id (FK → EquipmentType), width, depth, height, handle_length, handle_width, handle_location (enum), angle_type (enum), image_url (str), unique constraint on (series_id, name)
Material	id (PK), name (str), base_color (str), linear_yard_width (float), cost_per_linear_yard (float), weight_per_linear_yard (float), labor_time_minutes (float)
MaterialColourSurcharge	id (PK), material_id (FK → Material), colour (str), surcharge (float)
Supplier	id (PK), name (str)
SupplierMaterial	id (PK), supplier_id (FK → Supplier), material_id (FK → Material), unit_cost (float)
Customer	id (PK), name (str), address (str), phone (str)
Order	id (PK), customer_id (FK), marketplace (enum), marketplace_order_number (str), order_date (datetime)
OrderLine	id (PK), order_id (FK), model_id (FK), material_id (FK), colour (str), quantity (int), handle_zipper (bool), two_in_one_pocket (bool), music_rest_zipper (bool), unit_price (float)
PricingOption	id (PK), name (str), price (float)
ShippingRate	id (PK), carrier (enum), min_weight (float), max_weight (float), zone (str), rate (float), surcharge (float)
Marketplace Templates
Model	Purpose
AmazonProductType	id, code (e.g., “Carrier_Bag_Case”), name/description
ProductTypeKeyword	id, product_type_id (FK), keyword
ProductTypeField	id, product_type_id (FK), field_name, attribute_group, required (bool), order_index (int), description
ProductTypeFieldValue	id, product_type_field_id (FK), value (str)
These tables store the layout and valid values extracted from Amazon XLSX templates.
3. Technology Stack & Architecture
•	Backend: Python 3.11, FastAPI, SQLAlchemy, Alembic, Pydantic, Pandas / OpenPyXL for Excel parsing, Uvicorn for development server.
•	Database: SQLite for local development; switchable to PostgreSQL by changing the connection string and running Alembic migrations.
•	Frontend: React (with Create React App or Vite) + Material UI (or Ant Design). Axios for HTTP calls.
•	Docker (optional): For deployment, provide Dockerfiles for API and client.
4. Implementation Phases with Detailed Prompts
Phase 4.1 – Project Setup & Bootstrapping
Backend
1.	Create virtual environment & install dependencies
2.	python3 -m venv env
3.	source env/bin/activate
4.	pip install fastapi uvicorn sqlalchemy alembic pydantic openpyxl pandas python-multipart
5.	Initialize Alembic
6.	alembic init alembic
7.	Set up FastAPI app structure – create directories app/models, app/schemas, app/api, app/services.
Prompt for Gemini Studio:
“Generate a Python FastAPI project structure. Include main.py with a FastAPI instance, a database.py module that sets up SQLAlchemy engine and sessionmaker for SQLite, and a basic /health endpoint.”
Frontend
1.	Create React project
2.	npx create-react-app cover-app --template typescript
3.	cd cover-app
4.	npm install @mui/material @emotion/react @emotion/styled axios
5.	Set up folder structure – src/components, src/pages, src/services, src/types.
Prompt for Gemini Studio:
“Create a React TypeScript project with Material UI installed. Generate a folder structure with directories for components, pages, services and types.”
Phase 4.2 – Database Models & Migrations
1.	Define SQLAlchemy models based on the tables listed above. Use Python Enum classes for carriers, handle locations and angle types.
2.	Add Alembic revision to create tables. Run alembic revision --autogenerate -m "initial schema" and alembic upgrade head.
3.	Seed baseline data – Insert handle location and angle type enums, default materials, and pricing options.
Prompt:
“Define SQLAlchemy models for Manufacturer, Series, Model, EquipmentType, Material, MaterialColourSurcharge, Supplier, SupplierMaterial, Customer, Order, OrderLine, PricingOption and ShippingRate. Use declarative_base. Define enums for handle_location (top, side, back, none) and angle_type. Create an Alembic migration to generate these tables. Then write a seeding script that inserts default equipment types (e.g., ‘Guitar Amplifier’) and material types (waterproof, waterproof + padding, etc.).”
Phase 4.3 – API Endpoints
Implement CRUD routers for each entity. Use Pydantic schemas for request bodies and responses. Example endpoints:
•	POST /manufacturers, GET /manufacturers, GET /manufacturers/{id}.
•	POST /series (requires manufacturer_id), GET /series?manufacturer_id=....
•	POST /models, GET /models?series_id=..., etc.
•	POST /materials, GET /materials.
•	POST /orders with nested order lines.
•	POST /pricing/calculate – body includes model_id, material_id, colour, quantity, options; returns area, material_cost, labour_cost, option_surcharge, shipping_cost and total.
Use dependency injection to obtain a DB session in each route. Handle exceptions (e.g., duplicates) and return HTTP 400 as needed.
Prompt:
“For the Model entity, generate Pydantic schemas ModelCreate and ModelResponse. Implement a FastAPI router with endpoints to list models (filterable by series), create a model, update a model, and delete a model. Validate that model names are unique within a series and return appropriate HTTP errors.”
“Implement a PricingService in Python that provides methods: calculate_area(width, depth, height), cost_per_square_inch(material), calculate_labour_cost(material), calculate_option_surcharge(handle_zipper, two_in_one_pocket, music_rest), calculate_shipping_cost(weight, carrier, zone). Implement a /pricing/calculate endpoint that uses this service.”
Phase 4.4 – Amazon Template Import & Storage
1.	File upload endpoint – create POST /templates/import that accepts an Excel file (using FastAPI’s UploadFile). Determine the product type code from the filename or request parameter.
2.	Parse Data Definitions – use pandas.read_excel to load the “Data Definitions” sheet; extract field names, attribute groups and required flags.
3.	Parse Template – load the “Template” sheet (header row is usually row 5) and determine the column order. Map each column to a ProductTypeField with its order_index.
4.	Parse Valid Values – read the “Valid Values” sheet; for each column with restricted values, create ProductTypeFieldValue records.
5.	Parse Keywords – read the “Dropdown Lists” sheet to extract item_type_keyword values and add them to ProductTypeKeyword.
Prompt:
“Write a function import_amazon_template(file: UploadFile, product_code: str) in FastAPI that: reads the ‘Data Definitions’ sheet, extracts attribute names, groups and required flags; reads the ‘Template’ sheet to determine column order; reads the ‘Valid Values’ sheet and maps valid values to each attribute; reads the ‘Dropdown Lists’ sheet to extract item_type_keyword. Save these details into the database tables AmazonProductType, ProductTypeKeyword, ProductTypeField and ProductTypeFieldValue. Return the number of fields imported.”
“Write an endpoint /templates/{product_code}/fields that returns the list of fields and their valid values for a given product type.”
Phase 4.5 – Pricing & Shipping Logic
1.	Area Calculation – For rectangular covers: area = 2*(width*depth + width*height + depth*height); apply 5 % waste.
2.	Material & Colour Cost – cost_per_sq_inch = cost_per_linear_yard / (linear_yard_width * 36); multiply by area × 1.05 (waste). Add colour surcharge if selected.
3.	Labour Cost – labour_cost = (material.labor_time_minutes / 60) * labour_rate_per_hour.
4.	Options – Add fixed surcharges for top handle zippers, two in one pockets and music rest zippers (these values are stored in PricingOption).
5.	Shipping – Determine weight per square inch from material properties; compute total weight with waste; look up shipping rate by carrier and weight; add zone surcharge.
Prompt:
“Expand the PricingService to accept an options object (e.g., {'handle_zipper': True, 'two_in_one_pocket': False, 'music_rest_zipper': True}), compute the cost for each selected option by looking up corresponding records in the PricingOption table, and include those in the final total.”
“Implement a function lookup_shipping_rate(weight, carrier, destination_state) that selects the appropriate rate from ShippingRate by weight bracket and zone. Use USPS zone tables as initial data.”
Phase 4.6 – Front End Pages & Components
1.	Entity Management Pages
o	Manufacturers/Series Page: table listing existing manufacturers with ability to add/edit. When selecting a manufacturer, show its series. Provide a form for adding new series.
o	Models Page: filter by series. Form for model creation (fields for name, dimensions, handle and angle drop downs, image URL field). Use dynamic validation.
o	Materials & Suppliers Page: list materials and their costs; allow selecting a supplier and entering supplier specific pricing.
o	Customers & Orders: pages to enter customer information, then create orders by selecting models/materials/options.
2.	Pricing Page: a UI form where the user selects a model and material, enters quantity, chooses colour and options, and sees a real time cost breakdown (fetch from /pricing/calculate).
3.	Template Management Page: allow uploading an Amazon template file via drag and drop; show imported fields and keywords. Provide toggles to enable/disable fields for export. Display valid values as dropdowns.
4.	Export Page: user chooses marketplace (Amazon/Ebay/Reverb), product type (for Amazon), and enters values for each required field (or uses placeholders like {{width}}). On submit, send a request to /export and download the resulting file.
Prompt:
“Implement a React component TemplateImport that uses Material UI’s Dropzone to upload an XLSX file. On drop, call POST /templates/import with the file. After uploading, fetch and display the imported fields in a DataGrid component.”
“Create a ModelForm component with controlled inputs for all model fields. Populate the handle location and angle type fields from enums retrieved via API. On submit, POST to /models and display success or error messages.”
“Develop a PricingCalculator component that fetches models, materials and pricing options, allows the user to select them, and calls /pricing/calculate to display the cost breakdown. Use React’s state hooks to update the UI in real time.”
Phase 4.7 – Export & Marketplace Integration
1.	Export Endpoint – POST /export accepts: product_type_code, an array of models or order lines, user entered field values (e.g., title, description with placeholders), and optional variation configuration. It returns an XLSX/CSV with correct column order.
2.	E commerce Integration (future) – Add endpoints and services to upload listings via Amazon SP API, eBay API or Reverb API, and to fetch marketplace orders. This will require OAuth credentials and token management.
Prompt:
“Write a FastAPI function generate_export(product_code: str, items: List[dict], user_fields: dict) that loads the template for the given product code, fills in required and optional fields with the provided data (resolving placeholders like {{width}} and {{height}}), and returns the file as a streaming response. Leave unused template columns blank.”
“Create a React page ExportListing that renders a form based on the product type’s fields, lets the user input values or choose placeholders, and posts to /export to download the finished spreadsheet.”
Phase 4.8 – Testing, Debugging & Deployment
1.	Unit & Integration Tests – Use pytest and FastAPI’s TestClient to test each endpoint. Write tests for template import (verify correct number of fields inserted), pricing calculations (verify correct cost values), and export generation.
2.	Front End Testing – Use React Testing Library to validate form validation and API integration. Use Jest snapshots for UI components.
3.	Debugging – Use Python’s logging module to record errors and key events. Enable FastAPI’s automatic docs for manual testing. On the client side, use browser dev tools and React Developer Tools.
4.	Deployment – Package backend in a Docker image using Uvicorn. Build the React app and serve the static files behind an Nginx or using a service like Vercel. Provide a docker-compose file to run the API and a PostgreSQL database together.
Prompt:
“Generate pytest test cases for the /templates/import endpoint to ensure that importing the Carrier_Bag_Case file creates the correct number of ProductTypeFields and ProductTypeFieldValues. Use pandas to inspect the file during the test.”
“Write a Dockerfile for the FastAPI backend that installs dependencies, copies source code, exposes port 8000 and runs Uvicorn. Write a docker-compose configuration that starts a PostgreSQL container and the API, sets environment variables (like DATABASE_URL), and defines appropriate volumes.”
5. Conclusion
This detailed plan outlines the core data structures, technology choices, implementation phases and concrete prompts needed to build the custom cover making application on a modern web stack using Cursor or Replit. Each phase contains targeted instructions and prompts you can feed into Gemini Studio to generate models, API endpoints, services, React components, tests and Docker configurations. By following these steps you will produce a robust, extensible system that supports local development with SQLite and scales seamlessly to a cloud database when you’re ready.
